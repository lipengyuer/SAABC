
软件架构静态演化（设计阶段或系统运行前的架构演化）。  
静态演化的需求情况：  
（1）对设计时演化来说，需要保持软件实现与架构的一致性及软件开发过程的顺利进行。  
（2）对运行前演化来说，（由于运行环境、需求等发生变化）需要对软件进行修改升级。  

静态演化的一般过程：  
（1）软件理解。  
（2）需求变更分析。  
（3）演化计划。  
（4）系统重构。  
（5）系统测试。

静态演化的原子演化操作：  
（1）与可维护性相关的操作。增删模块间的依赖，增删模块之间的接口，增删模块，拆分/聚合模块等。  
（2）与可靠性相关的演化操作。增删消息、增删交互对象、增删消息片段、增删用例执行、增删角色等。

正交软件架构(对功能进行分层和线索化)对静态演化的支持非常好。  
正交软件架构的演化过程：  
（1）需求变动归类，使需求的变化和现有组件及线索相对应，判断重用情况（是否有可复用模块）。  
（2）制定架构演化计划。  
（3）修改、增加或删除组件。  
（4）更新组件之间的相互作用。  
（5）产生演化后的新架构，作为系统更新的详细设计方案和实现基础。  


软件架构动态演化。  
需要动态演化的场景：  
（1）软件内部执行所导致的体系结构改变。大型促销期间、订单数量快速上涨，电商订单处理平台自动扩容。  
（2）软件系统外部的请求对软件进行的重配置。操作系统升级。  

为什么需要动态演化？停机进行更新或维护的代价非常高昂（生命维持、交通等）。

软件动态性的等级：  
（1）交互动态性。  
（2）结构动态性。  
（3）架构动态性。  

| 维度           | 交互动态性               | 结构动态性               | 架构动态性                 |
|----------------|--------------------------|--------------------------|----------------------------|
| 调整粒度       | 参数、接口、数据流       | 组件实例、插件           | 架构风格、拓扑结构         |
| 典型工具       | 配置中心、动态代理       | 容器编排（K8s）、反射    | 架构描述语言（AADL）、热部署框架 |
| 示例           | 动态切换排序策略         | 微服务扩缩容             | 单体到微服务迁移           |
| 风险等级       | 低（局部调整）           | 中（组件级变更）         | 高（架构级重构）           |
| 适用场景       | 快速配置变更             | 弹性扩展、插件生态       | 技术栈升级、架构演进       |
| 例子       | 通过数据控制相关模块的动作（比如选择代码执行的分支）             | 增减模块、节点       | 很少       |

动态演化的内容：    
（1）属性改名。进改变变量名称，不改变数据内容、程序行为，是非常小的重构动作。目的在于提升代码可阅读性，或者实现与某些系统的字段名统一。    
（2）行为变化。 修改组件的功能、算法或者交互协议，导致系统行为发生改变。比如在（电商平台的）配置中心修改促销规则。   
（3）拓扑结构改变。调整组件间的连接关系、通信路径或系统拓扑（如新增 / 删除组件连接、改变消息路由方式）。比如，将用户请求从单体架构逐步迁移至微服务：(旧拓扑)用户 → 单体应用 → 数据库；(新拓扑)用户 → API 网关 → 订单微服务 → 库存微服务 → 数据库（通过 Nginx 动态代理规则，逐步将部分流量转发至微服务接口）。  
（4）风格变化。新架构最好是旧架构的衍生架构。常见的场景是单体架构演化为微服务架构。

实现软件架构动态演化的技术：  
（1）动态软件架构。  
（2）动态重配置。  

动态软件架构实施动态演化的步骤：  
（1）捕捉并分析需求变化。  
（2）获取或生成体系结构演化策略。  
（3）根据步骤（2）得到的演化策略实施演化。  
（4）演化后的评估与检测。  

反射，可以简单理解为基于字符串形式的配置或数据构建类的实例，进行在程序中按需使用类的功能进行特定操作。比如将json串反序列化为列表等基本数据类型，然后进行下游的计算；或者基于插件名创建相应实例等。

按照描述视角可以将软件动态性建模语言分为3类：  
（1）基于行为视角的pi-ADL。使用数学表达式来表达和验证动态性的行为。  
```
A = ch!msg. A'  #组件 A 向通道ch发送消息msg，
B = ch?x. B' #组件 B 从ch接收消息，可形式化为：
```
（2）基于反射视角的Pilar。反射是一种常用的实现方式。  
（3）基于协调视角的LIME。适合分布式系统。 

有专门的工具支持动态软件架构的动态演化。

动态软件架构的实现方式是比较简单的：使用特定的插件或库实现对配置信息的检测、加载和使用。比如[python代码热更原理及实现](https://blog.csdn.net/qq_37744360/article/details/131183572)

动态重配置，指的是软件部署后、对配置信息的修改，常备用来做系统动态升级时需要进行的配置信息修改。

动态重配置涉及的修改有：  
（1）简单任务的相关实现修改。  
（2）工作流实例任务的添加和删除。  
（3）组合任务流程中的个体修改。  
（4）任务输入来源的添加和删除。  
（5）任务输入来源的优先级修改。  
（6）组合任务输出目标的添加和删除。  
（7）组合任务输出的目标的优先级修改。  


动态重配置的应用很广泛，比如在任务参数较多的语言模型预训练中经常使用。仍然是基于特定的插件或库来实现，比如[Python 配置文件热更新 原](https://blog.51cto.com/u_16213414/12466543)



